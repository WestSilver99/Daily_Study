# CPU 스케줄링

<br/>

## 스케줄링의 개요

 <br/>

### CPU 스케줄링

<br/>

- 운영체제에서 레스토랑 관리자의 역할을 담당

- 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원의 배정을 결정

<br/>

- 고수준 스케줄링

  - 시스템 내의 전체 작업 수를 조절하는 것

  - 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정
  - 시스템 내에서 동시에 실해 가능한 프로세스의 총 개수가 정해짐
  - 장기 스케줄링, 작업 스케줄링, 승인 스케줄링이라고도 함

- 저수준 스케줄링

  - 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 결정

  - 아주 짧은 시간에 일어나므로 단기 스케줄링이라고도 함

- 중간수준 스케줄링

  - 중지와 활성화로 전체 시스템의 활성화된 프로레스 수를 조절하여 과부하 막음
  - 일부 프로세스를 중지 상태로 ㅇ롬겨 나머지 프로세스가 원만히 작동하도록 지원
  - 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할

<br/>

- 정리

| 고수준 스케줄링    | 전체 시스템의 부하를 고려하여 작업을 시작할지 말지 결정                                                     |
| ------------------ | ----------------------------------------------------------------------------------------------------------- |
| 중간 수준 스케일링 | 시스템 과부하가 걸려서 젠체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세스 중 일부를 보류 상태로 보냄 |
| 저수준 스케줄링    | 실제 작업 수행                                                                                              |

<br/>

CPU 스케줄링의 목적

- 공평성
- 효율성
- 안정성
- 확장성
- 반응 시간 보장
- 무한 연기 방지

<br/>

선점형 스케줄링

- 운영체제가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단시키고 새로운 작업을 시작할 수 있는 방식

- 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응단 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합
- 대부분의 저수준 스케줄러는 선점형 스케줄러 방식을 사용

<br/>

비선점형 스케줄링

- 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행되는 방식

- 선점형 스케줄링보다 스케줄러의 작업량이 적고 문잭 교환에 의한 낭비도 적음
- CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어짐
- 과거의 일괄 작업 시스템에서 사용하던 방식

<br/>

프로세스 우선순위

- 커널 프로세스의 우선순위가 일반 프로세스보다 높음

- 시스템에는 다양한 우선순위의 프로세스가 공존하며 우선순위가 높은 프로세스가 CPU를 먼저, 더 오래 차지
- 시스템에 따라 높은 숫자가 높은 우선순위를 나타내기도 하고, 낮은 숫자가 높은 우선순위를 나타내기도 함

<br/>

### CPU 집중 프로세스와 입출력 집중 프로세스

<br/>

CPU 집중 프로세스

- 수학 연산과 같이 CPU를 많이 사용하는 프로세스로 CPU 버스트가 많은 프로세스

입출력 집중 프로세스

- 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스로 입출력 버스트가 많은 프로세스

<br/>

우선 배정

- 스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율이 향상

<br/>

전면 프로세스

- GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
- 현재 입력과 출력을 사용하는 프로세스
- 사용자와 상호작용기 가능하여 상호작용 프로세스라고도 함

후면 프로세스 : <span style="color:red">오래걸리는 압축풀기등</span>

- 사용자와 상호작용이 없는 프로세스
- 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 함
- 전면 프로세스의 우선순위가 후면 프로세스보다 높음

<br/>

<img src="https://blog.kakaocdn.net/dn/TtjMz/btqJsjvRwaz/2hOkqyiNlFRBkfQgUWjpKK/img.png">

<br/>

## 다중 큐

준비 상태의 다중 큐

- 프로세스는 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입

- CPU 스케줄러는 우선순위가 가장 높은 큐(0번 큐)의 맨 앞에 있는 프로세스 6에 CPU 할당

고정 우선순위 방식

- 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
- 프로세스가 작업하는 동안 우선순위가 변하지 않기 때문에 구현은 쉽지만, 시스템 상황이 시시각각 변하는데 우선순위를 고정하면 시스템 변화에 대응하기 어려워 작업 .....

대기 상태의 다중 큐

- 시스템 효율을 높이기 위해 같은 입출력을 요구한 프로세스끼리 모아 놓음

## 다중 큐

<img src="https://velog.velcdn.com/images%2Ftnwls2%2Fpost%2F0eebfb0f-05f4-4cec-a9f2-b0f9a2ea5d0a%2Fimage.png">

<br/>

### 스케줄링 알고리즘의 선택 기준

| 구분 | 종류 |
| ---- | ---- |

<br/>

- CPU 사용률

  - 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법
  - 가장 이상적인 수치는 100%이지만 실제로는 여러 가지 이유로 90%에도 못 미침

- 처리량

  - 단위 시간당 작업을 마친 프로세스의 수
  - 이 수치가 클수록 좋은 알고리즘임

- 대기 시간
  - 작업을 요청한 프로세스가 작업 시작 전까지 대기하는 시간
  - 이 시간이 짧을수록 좋음

스케줄링 알고리즘의 평가 기준

- 응답 시간

  - 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
  - 이 시간이 짧을수록 좋음

- ## 반환 시간
  -
- 대기 시간

<br/>

평균 대기 시간

- 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값

<br/>

FCFS 스케쥴링의 동작 방식

- 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
- 한번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행 할 수 있음
- 큐가 하나라 모든 프로세스는 우선순위가 동일

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%203.png">

<br/>

FCFS 스케줄링의 성능
<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%204.png">
<br/>

평균 대기 시간<br/>
(0 + 27 + 42) / 3 = 23밀리초

<br/>
<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%205.png">

<br/>

FCFS 스케줄링의 평가

- 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어짐

- 특히 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어짐

<br/>

### SJF 스케줄링의 동작 방식

- 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비식

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%207.png">

<br/>

평균 대기 시간<br/>
(0 + 24 + 36 ) / 3 = 20 밀리초

<br/>

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%208.png">

<br/>

SJF 스케줄링의 평가

- 운영체제가 프로시스의 종료 시간을 정확하게 예측하기 어려움

- 작업 시간이 길다는 잉만으로 계속 뒤로 밀려 공평성이 현저히 떨어짐. 이를 아사 현상 이라 부름

<br/>

에이징

- 아사 현상의 완화 방법
- 프로세스가 양보할 수 있는 상한선을 정하는 방식
- 프로세스가 자신의 순서를 양보할 때마다 나이를 한 살씩 먹어 최대 몇 살까지 양보하도록 규정하는 것

<br/>

HRN 스케줄링의 동작 방식

- JF의 아사현상을 해결하기 위해 만들어진 비선점형 알고리즘
- 최소 응답률 우선 스케줄링이라고도 함
- 서비스를 받기 위해 기다린 시간 + CPU 사용 시간을 고려해 스케줄링을 하는 방식
- 프로세스의 우선순위를 결정하는 기준

<br/>

HRN 스케줄링의 성능
<br/>

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%209.png">

<br/>

HRN 스케줄링의 평가

- 실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을 완화
- 대기 시간이 긴 프로세스의 우선순위를 높여 CPU 할당 확률을 높임
- 우선순위 할당에 CPU 사용 시간이 개입하므로 완전히 공평하지는 않음

<br/>

라운드 로빈 스케줄링의 동작 방식

- 한 프로세스가 할당받은 시간 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식

- 선점형 알고리즘 중 가장 단순하고 대표적인 방식

- 중간에 종료되거나 자발적으로 종료되지 않아도 운영체제에 의해 CPU 사용권을 빼앗길 수 있음

- 프로세스들이 작업을 완료할 때 까지 계속 순환

<br/>

라운드 로빈 스케줄링의 성능

<br/>

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%2010.png">

<br/>

라운드 로빈 스케줄링의 평가

- 라운드 로빈 스케줄링과 FCFS 스케줄링의 평균 대기 시간이 같다면 라운드 로빈 스케줄링이 더 비효율

- 라운드 로빈 스케줄링 같은 선점형 방식에는 문맥 교환 시간이 추가되기 때문

<br/>

SRT 스케줄링의 동작 방식

- 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택

<br/>

SRT 스케줄링의 성능

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%2011.png">

<br/>

SRT 스케줄링의 평가

- 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링 ... ....
- 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산해야함
  - 운영체제의 부담이 조금 커질 수 있음
- 운영체제가 프로세스의 종료 시간을 예측하기 어려움
- 아사 현상이 일어남

<br/>

우선순위 스케줄링의 동작 방식

- 프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘

<br/>

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%2012.png">

<br/>

우선순위는 비선점형 방식과 선점형 방식 모두 적용 가능

- SJF 스케줄링 : 작업 시간이 짧은 프로세스

- HRN 스케줄링 : 작업 시간이 짧거나 대기 시간이 긴 프로세스
- SRT 스케줄링 : 남은 시간이 짧은 프로세스
  - 고정 우선순위 알고리즘
- 한번 우선순위를 부여받으면 종료될때까지 우선순위 고정
- 단순하게 구현 가능
- 변동적인 시스템의 상황 반영 불가능 -효율 떨어짐
  변동 우선순위 알고리즘
- 일정 시간마다 우선순위 변동
- 우선순위 계산, 반영 복잡
- 효율적인 운영 가능

<br/>

우선순위 스케줄링 평가

- 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU 할당

  - 공평성 위배
  - 프로세스의 우선순위를 매번 재계산해야 하므로 시스템의 효율을 떨어뜨림

- 아사 현상을 일으킴
- 커널 프로세스가 우선

<br/>

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%2013.png">

<br/>

다단계 피드백 큐 스케줄링의 동작 방식

- 프로세스가 CPU를 한번씩 할당받아 실행될 때 마다 우선순위가 낮아짐
  다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제 완화
- 우선순위가 낮아진다고 해도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음
- 우선순위에 따라 타임 슬라이스의 크기가 다름

- 우선순위가 낮아질수록 CPU를 얻을 확률이 적어짐. 따라서 한번 CPU를 잡을 때 많이 작업하라고 낮은 우선순위의 타임 슬라이스를 크게 함

- 마지막 큐에 있는 프로세스는 무한대의 타임 슬라이스를 얻음
- 마지막 큐는 들어온 순서대로 작업을 마치는 FCFS 스케줄링 방식을 사용

<img src="https://yansigit.github.io/posts/cpu-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98/Untitled%2014.png">
